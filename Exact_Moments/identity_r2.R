  
  
  ############################################################################
  ### IDENTITY
  ############################################################################
  
  
  # --------------------------------------------------------------------------
  # Cyril Bachelard
  # This version:     20.07.2022
  # First version:    20.07.2022
  # --------------------------------------------------------------------------
  
  
  # Description:
  # This scripts defines an (arbitrarily) real-valued vector z and computes the 
  # RHS and LHS of the identity for two cases:
  # 1) Weights are distributed over a grid on the simplex (of dimension n). 
  # The grid is generated by computing all possible partitions of integer n and all 
  # possible permutations (this can only be done for n < 9).
  # 2) Weights follow a Dirichlet distribution. In the example below, the parametrization
  # of the Dirichlet distribution is such that weights are uniformly distributed over the
  # simplex. However, this can be changed (parameter alpha). 
  
  
  
  
  require(partitions)
  require(gtools)
  
  
  
  
  
  
  # --------------------------------------------------------------------------
  # Data and parameters
  # --------------------------------------------------------------------------
  
  # Define real-valued vector z
  n <- 4
  z <- 1:n
  
  # Number of simulations (for the Dirichlet sampling case)
  n_sim <- 10^6
  
  
 
  
  # --------------------------------------------------------------------------
  # Weights follow a Grid G over the simplex
  # --------------------------------------------------------------------------
  
  # Define grid G (exactly, using partitions and permutations)

  # Partitions
  parts_mat <- partitions::parts( n )
  draws <- gridDraws( parts_mat = parts_mat, cnames = FALSE )
  prob <- draws2prob( draws = draws )
  prob_tot <- prob * draws[2, ]
  
  # Permutations
  lP <- list()
  lTheta <- list()
  for( j in 1:ncol(parts_mat) ) {
    
    if ( length(unique(parts_mat[ ,j])) > 1 ) {
      perm <- gtools::permutations( n = n, 
                                    r = n, 
                                    v = parts_mat[ ,j], 
                                    set = FALSE,
                                    repeats.allowed = FALSE )
      perm_unique <- perm[!duplicated(perm), ]
    } else {
      perm_unique <- t(parts_mat[ ,j])
    }
    lP[[j]] <- perm_unique
    theta <- apply( perm_unique / n, 1, function(p) { sum(p * z) } )
    lTheta[[j]] <- theta
  }
  gridnodes_all <- do.call( rbind, lP )
  Grid <- gridnodes_all / n
  Grid
  dim(Grid)
  
  # Grid node activation probabilities (there are k \in \{1, ..., K\} grid nodes)
  lProb <- lapply( 1:length(lP), FUN = function(i) { rep(prob[i], nrow(lP[[i]])) } )
  prob_k <- unlist(lProb)

  # Norms on weights (grid nodes)
  w_bar <- rep(1/n, n)
  squared_2norm_w_bar <- sum(w_bar^2)
  exact_expected_squared_2norm <- (2*n-1) / n^2 
  expected_squared_2norm <- sum( apply( Grid, 1, function(w) { sum(w^2) } ) * prob_k )
  expected_squared_2norm; exact_expected_squared_2norm  # should be the same
  
  
  # Compute RHS of identity
  z_bar <- sum( w_bar * z )
  b <- z - mean(z)
  m2_biased <- sum( w_bar * b^2 )
  # bias_correction <- sum(w_bar)^2 / (sum(w_bar)^2 - sum(w_bar^2))  # = 1 / (1 - sum(w_bar^2))
  bias_correction <- n / (n - 1)
  m2 <- m2_biased * bias_correction
  RHS <- m2 * ( exact_expected_squared_2norm - squared_2norm_w_bar )
  
  
  # The LHS of the identy can be computed in several ways
  tmp <- apply( Grid, 1, function(w) { sum(w * b)^2 } )
  LHS_version1 <- sum( prob_k * tmp )
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 2)
  for ( k in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[k, ])
    Ans[k, 1] <- sum(g^2 * b^2)
    tmp <- 0
    for ( i in 1:(n-1) ) {
      for ( j in (i+1):n ) {
        tmp <- tmp + g[i] * g[j] * b[i] * b[j] * 2
      }
    }
    Ans[k, 2] <- tmp
  }
  LHS_version2 <- sum( apply( Ans, 2, function(a) { sum(a * prob_k) } ) )
  

  # Or, use E(w_i^2) and E(w_i w_j)
  W <- t( apply( Grid, 1, function(g) { (g %*% t(g))[upper.tri(g %*% t(g))] } ) )
  if ( nrow(W) == 1 ) W <- t(W)
  wiwj_bar <- apply( W * prob_k, 2, sum )
  wiwj_bar_mat <- matrix(NA, nrow = n, ncol = n, byrow = TRUE)
  wiwj_bar_mat[upper.tri(wiwj_bar_mat)] <- wiwj_bar
  wisq_bar <- apply( Grid^2 * prob_k, 2, sum )
  tmp <- 0
  for ( i in 1:(n-1) ) {
    for ( j in (i+1):n ) {
      tmp <- tmp + wiwj_bar_mat[i, j] * b[i] * b[j] * 2
    }
  }
  LHS_version3 <- sum(wisq_bar * b^2) + tmp
  
  
  wisq_bar; (2*n - 1) / n^3
  wiwj_bar; (n - 1) / n^3
  
  
  LHS_version1
  LHS_version2
  LHS_version3
  RHS
  
  
  
  
  exact_expected_squared_2norm
  sum(wisq_bar)
  
  
  
  # Or, use E(w_i^2) and E(w_i w_j)
  W <- t( apply( Grid * n, 1, function(g) { (g %*% t(g))[upper.tri(g %*% t(g))] } ) )
  if ( nrow(W) == 1 ) W <- t(W)
  wiwj_bar <- apply( W * prob_k, 2, sum )
  wiwj_bar_mat <- matrix(NA, nrow = n, ncol = n, byrow = TRUE)
  wiwj_bar_mat[upper.tri(wiwj_bar_mat)] <- wiwj_bar
  wiwj_bar_mat
  
  
  
  
  
  
  ###############################################
  
  # Weights follow a multinomial distribution 
  #// check out wiki on binomial distribution for the first six raw and central moments
  #// check out link to Stirling numbers of the second kind, falling power
  
  p <- rep(1/n, n)
  p %*% t(p)
  
  
  
  exact_expected_squared_2norm
  2/n - 1/n^2
  p * (1 - p) + p
  sum(n * p * (1 - p) + n * p) / n
  sum(p * (1 - p) + p) / n
  
  
  # non-central moments
  (n * p * (1 - p) + n^2 * p^2) / n
  
  
  
  (n*p)^2
  p^2
  
  
  
  
  # m3
  n * p * (1 - p) * (1 - 2*p)
  (n * p * (1 - p) * (1 - 2*p)) / n
  (5*n^2 - 6*n + 2) / n^4
  
 
  
  
  
  
  
  
  
    
  
  # --------------------------------------------------------------------------
  # Weights follow a symmetric Dirichlet distribution, alpha_0 <> n
  # --------------------------------------------------------------------------
  
  
  # Sample weights from a Dirichlet distribution (with symmetric parameter)
  lambda <- 0.1
  alpha <- rep(1, n) * lambda
  samples <- rdirichlet( n = n_sim, alpha = alpha )
  
  # Compute theta_hat for all sampled weights
  theta_hat <- apply( samples, 1, function(w) { sum(w * z) } )
  
  # Norms on weights
  w_bar <- alpha / sum(alpha)
  squared_2norm_w_bar <- sum(w_bar^2)
  expected_squared_2norm <- mean( apply( samples, 1, function(w) { sum(w^2) } ) )
  exact_expected_squared_2norm <- (1 + lambda) / (1 + lambda * n) # Follows from the properties of the Dirichlet distribution
  expected_squared_2norm; exact_expected_squared_2norm # they should be close
  
  alpha_0 <- sum(alpha)
  (alpha * (alpha + 1)) / (alpha_0 * (alpha_0 + 1))
  sum( (alpha * (alpha + 1)) / (alpha_0 * (alpha_0 + 1)) )
  
  
 
  
  
  # Compute RHS of identity
  z_bar <- sum( w_bar * z )
  b <- z - z_bar
  m2_biased <- sum( w_bar * (z - z_bar)^2 )
  bias_correction <- sum(w_bar)^2 / (sum(w_bar)^2 - sum(w_bar^2))  # = 1 / (1 - sum(w_bar^2))
  m2 <- m2_biased * bias_correction
  RHS <- m2 * ( exact_expected_squared_2norm - squared_2norm_w_bar )
  RHS
  M2Exact( z = z, 
           w_bar = w_bar, 
           exp2norm2 = exact_expected_squared_2norm )
  
  

  # Compute LHS, based on E(w_i^2) and E(w_i w_j)
  wisq_bar <- (1 + lambda) / (n * (1 + lambda * n))
  wiwj_bar <- lambda / (n * (n*lambda + 1))
  wiwj_bar_mat <- matrix(NA, nrow = n, ncol = n, byrow = TRUE)
  wiwj_bar_mat[upper.tri(wiwj_bar_mat)] <- wiwj_bar
  tmp <- 0
  for ( i in 1:(n-1) ) {
    for ( j in (i+1):n ) {
      tmp <- tmp + wiwj_bar_mat[i, j] * b[i] * b[j] * 2
    }
  }
  LHS <- sum(wisq_bar * b^2) + tmp
  
    
  # Compare RHS, LHS and numerical result
  RHS
  LHS
  var(theta_hat)  
  
  
  
  
  
  
  # --------------------------------------------------------------------------
  # Weights follow an asymmetric Dirichlet distribution
  # --------------------------------------------------------------------------
  
  
  # Sample weights from a Dirichlet distribution (with symmetric parameter)
  alpha <- 1:n / sum(1:n) #* n
  samples <- rdirichlet( n = n_sim, alpha = alpha )
  
  # Compute theta_hat for all sampled weights
  theta_hat <- apply( samples, 1, function(w) { sum(w * z) } )
  
  # Norms on weights
  w_bar <- alpha / sum(alpha)
  squared_2norm_w_bar <- sum(w_bar^2)
  expected_squared_2norm <- mean( apply( samples, 1, function(w) { sum(w^2) } ) )
  exact_expected_squared_2norm <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  
  expected_squared_2norm; exact_expected_squared_2norm # they should be close
 
  
  # Compute RHS of identity
  z_bar <- sum( w_bar * z )
  b <- z - z_bar
  m2_biased <- sum( w_bar * (z - z_bar)^2 )
  bias_correction <- sum(w_bar)^2 / (sum(w_bar)^2 - sum(w_bar^2))  # = 1 / (1 - sum(w_bar^2))
  m2 <- m2_biased * bias_correction
  RHS <- m2 * ( exact_expected_squared_2norm - squared_2norm_w_bar )
  RHS
  M2Exact( z = z, 
           w_bar = w_bar, 
           exp2norm2 = exact_expected_squared_2norm )
  
  
  # Compute LHS, based on E(w_i^2) and E(w_i w_j)
  wisq_bar <- unlist( lapply( alpha, FUN = betaMoments, b = sum(alpha), m = 2 ) )
  wiwj_bar_mat <- matrix(alpha, nrow = n) %*% matrix(alpha, ncol = n) / (sum(alpha) * (sum(alpha) + 1) )
  tmp <- 0
  for ( i in 1:(n-1) ) {
    for ( j in (i+1):n ) {
      tmp <- tmp + wiwj_bar_mat[i, j] * b[i] * b[j] * 2
    }
  }
  LHS <- sum(wisq_bar * b^2) + tmp
  
  
  # Compare RHS, LHS and numerical result
  RHS
  LHS
  var(theta_hat)  
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    
  
  
  
  
  
  
  
  
  
  
  