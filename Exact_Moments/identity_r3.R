  
  
  ############################################################################
  ### IDENTITY FOR r=3
  ############################################################################
  
  
  # --------------------------------------------------------------------------
  # Cyril Bachelard
  # This version:     20.07.2022
  # First version:    20.07.2022
  # --------------------------------------------------------------------------
  
  
  # Description:
  # This scripts defines an (arbitrarily) real-valued vector z and computes the 
  # RHS and LHS of the identity for two cases:
  # 1) Weights are distributed over a grid on the simplex (of dimension n). 
  # The grid is generated by computing all possible partitions of integer n and all 
  # possible permutations (this can only be done for n < 9).
  # 2) Weights follow a Dirichlet distribution. In the example below, the parametrization
  # of the Dirichlet distribution is such that weights are uniformly distributed over the
  # simplex. However, this can be changed (parameter alpha). 
  
  
  
  
  
  require(partitions)
  require(gtools)
  
  
  wd <- "H:/R/notingit/Bootstrap/"
  source( paste0(wd, "Source/custom_functions.R") )
  
  
  # --------------------------------------------------------------------------
  # Helper functions
  # --------------------------------------------------------------------------
  
  # --------------------------------------------------------------------------
  rdirichlet <- function( n, alpha ) 
  {
    l <- length(alpha)
    x <- matrix( rgamma(l * n, alpha), ncol = l, byrow = TRUE )
    sm <- x %*% rep(1, l)
    ans <- x / as.vector(sm)
    return( ans )
  }
   
  
  # --------------------------------------------------------------------------
  gridDraws <- function ( parts_mat, cnames = FALSE ) 
  {
    FUN <- function ( x ) 
    {
      tmp <- table(x)
      num1 <- factorial(sum(x))
      if ( length(x) == sum(x) ) {
        num2 <- num1
      } else {
        num2 <- factorial(length(x))
      }
      n_paths_to_level_set <- num1 / prod(factorial(x))
      n_points_in_level_set <- num2 / prod(factorial(tmp))
      ans <- c(n_paths_to_level_set,
               n_points_in_level_set)
      return( ans )
    }
    ans <- apply( X = parts_mat, MARGIN = 2, FUN = FUN )
    rownames(ans) <- c("# paths to the same point", 
                       "# points in the same level set")
    if ( isTRUE(cnames) ) {
      colnames(ans) <- apply( X = parts_mat, 
                              MARGIN = 2, 
                              FUN = function(X) { paste(X, collapse = ".") } )
    }
    return( ans )
  }
  
  # --------------------------------------------------------------------------
  draws2prob <- function ( draws ) 
  {
    ans <- draws[1, ] / as.numeric(draws[1, ] %*% draws[2, ])
    return( ans )
  }
  
  
  # --------------------------------------------------------------------------
  betaMoments <- function( a, a0, m )
  {
    mvec <- 0:(m-1)
    # prod( a + mvec ) / prod( a + b + mvec )
    prod( (a + mvec) / (a0 + mvec) )
  }
  
  
  
  
  
  # --------------------------------------------------------------------------
  # Data and parameters
  # --------------------------------------------------------------------------
  
  # Define real-valued vector z
  n <- 4
  set.seed(1111)
  z <- rt(n = n, df = 3)^2
  
  w_bar <- rep(1/n, n)
  z_bar <- sum( w_bar * z )
  b <- z - z_bar
  
  # Number of simulations (for the Dirichlet sampling case)
  n_sim <- 10^6
  
  
 
  
  # --------------------------------------------------------------------------
  # Weights follow a Grid G over the simplex
  # --------------------------------------------------------------------------
  
  # Define grid G (exactly, using partitions and permutations)

  # Partitions
  parts_mat <- partitions::parts( n )
  draws <- gridDraws( parts_mat = parts_mat, cnames = FALSE )
  prob <- draws2prob( draws = draws )
  prob_tot <- prob * draws[2, ]
  
  # Permutations
  lP <- list()
  lTheta <- list()
  for( j in 1:ncol(parts_mat) ) {
    
    if ( length(unique(parts_mat[ ,j])) > 1 ) {
      perm <- gtools::permutations( n = n, 
                                    r = n, 
                                    v = parts_mat[ ,j], 
                                    set = FALSE,
                                    repeats.allowed = FALSE )
      perm_unique <- perm[!duplicated(perm), ]
    } else {
      perm_unique <- t(parts_mat[ ,j])
    }
    lP[[j]] <- perm_unique
    theta <- apply( perm_unique / n, 1, function(p) { sum(p * z) } )
    lTheta[[j]] <- theta
  }
  gridnodes_all <- do.call( rbind, lP )
  Grid <- gridnodes_all / n
  Grid
  dim(Grid)
  
  # Grid node activation probabilities (there are k \in \{1, ..., K\} grid nodes)
  lProb <- lapply( 1:length(lP), FUN = function(i) { rep(prob[i], nrow(lP[[i]])) } )
  prob_k <- unlist(lProb)

  # Norms on weights (grid nodes)
  w_bar_3norm3 <- sum(w_bar^3)
  exact_expected_2norm2 <- (2*n-1) / n^2 
  exact_expected_3norm3 <- (5*n^2 - 6*n + 2) / n^4
  expected_2norm2 <- sum( apply( Grid, 1, function(w) { sum(w^2) } ) * prob_k )
  expected_3norm3 <- sum( apply( Grid, 1, function(w) { sum(w^3) } ) * prob_k )
 
  sum( apply( parts_mat / n, 2, function(x) { sum(x^2) } ) * prob_tot )
  expected_2norm2; exact_expected_2norm2  # should be the same
  
  sum( apply( parts_mat / n, 2, function(x) { sum(x^3) } ) * prob_tot )
  expected_3norm3; exact_expected_3norm3  # should be the same
 
  
  
  
  
  # Compute RHS of identity
  m3_biased <- sum( w_bar * b^3 )
  bias_correction <- biasCorrection( w_bar = w_bar, m = 3 )
  m3 <- m3_biased * bias_correction
  RHS <- M3Exact( z = z,
                  w_bar = w_bar,
                  exp3norm3 = exact_expected_3norm3,
                  expw2 = rep(exact_expected_2norm2 / n, n) )
  RHS
  
  
  
  # The LHS of the identy can be computed in several ways
  tmp <- apply( Grid, 1, function(w) { sum(w * b)^3 } )
  # tmp <- apply( Grid, 1, function(w) { (sum(w * z) - z_bar)^3 } )
  LHS_version1 <- sum( prob_k * tmp )
  LHS_version1


  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 3)
  wi3_mat <- matrix(0, nrow = 1, ncol = n)
  wi2wj_mat <- matrix(0, nrow = n, ncol = n)
  wiwjwk_array <- array(0, dim = c(n, n, n))
  
  for ( row_idx in 1:nrow(Grid) ) {
    wi2wj_mat_tmp <- wi2wj_mat * 0
    wiwjwk_array_tmp <- wiwjwk_array * 0
    g <- as.numeric(Grid[row_idx, ])
    Ans[row_idx, 1] <- sum(g^3 * b^3)
    wi3_mat[1, ] <- wi3_mat[1, ] + g^3 * prob_k[row_idx]
    tmp <- 0
    for ( i in 1:n ) {
      for ( j in 1:n ) {
        if ( i != j ) {
          wi2wj_mat_tmp[i, j] <- g[i]^2 * g[j]
          tmp <- tmp  + wi2wj_mat_tmp[i, j] * b[i]^2  * b[j] * 3
        }
      }
    }
    wi2wj_mat <- wi2wj_mat + wi2wj_mat_tmp * prob_k[row_idx]
    Ans[row_idx, 2] <- tmp
    tmp <- 0
    for ( i in 1:(n-2) ) {
      for ( j in (i+1):(n-1) ) {
        for ( k in (j+1):n ) {
          wiwjwk_array_tmp[i, j, k] <- prod(g[c(i, j, k)])
          tmp <- tmp  + wiwjwk_array_tmp[i, j, k] * prod(b[c(i, j, k)]) * 6
        }
      }
    }
    wiwjwk_array <- wiwjwk_array + wiwjwk_array_tmp * prob_k[row_idx]
    Ans[row_idx, 3] <- tmp
  }
  LHS_version2 <- sum( apply( Ans, 2, function(a) { sum(a * prob_k) } ) )
  LHS_version2
  
  wi3_mat
  wi2wj_mat
  wiwjwk_array
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    tmp <- 0
    for ( i in 1:n) {
      for (j in 1:n) {
        for (k in 1:n) {
          tmp <- tmp + prod(g[c(i, j, k)]) * prod(b[c(i, j, k)])
        }
      }
    }
    Ans[row_idx, 1] <- tmp
  }
  LHS_version3 <- sum( Ans[ ,1] * prob_k )
  LHS_version3
  
  
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  B_tmp <- b %*% t(b)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    G_tmp <- g %*% t(g)
    Ans[row_idx, 1] <- sum( kronecker( g * b, G_tmp * B_tmp ) )
  }
  LHS_version4 <- sum(Ans[ ,1] * prob_k) 
  
  
  
 
  
  # Or, use E(w_i^3), E(w_i^2 w_j) and E(w_i w_j, w_k)
 
  wi3_bar <- apply( Grid^3 * prob_k, 2, sum )
  tmp1 <- 0
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      if ( i != j ) {
        tmp1 <- tmp1 + wi2wj_mat[i, j] * b[i]^2  * b[j] * 3
      }
    }
  }
  tmp2 <- 0
  for ( i in 1:(n-2) ) {
    for ( j in (i+1):(n-1) ) {
      for ( k in (j+1):n ) {
        tmp2 <- tmp2 + wiwjwk_array[i, j, k] * prod(b[c(i, j, k)]) * 6
      }
    }
  }
  LHS_version5 <- sum(wi3_bar * b^3) + tmp1 + tmp2
  LHS_version5
  
  
  
  
  LHS_version1
  LHS_version2
  LHS_version3
  LHS_version4
  LHS_version5
  RHS
  
  
  
 
  
  
  # --------------------------------------------------------------------------
  # Weights follow a symmetric Dirichlet distribution, \alpha_0 <> n
  # --------------------------------------------------------------------------
  
  # Sample weights from a Dirichlet distribution (with symmetric parameter)
  lambda <- 0.1
  alpha <- rep(1, n) * lambda
  w_bar <- alpha / sum(alpha)
  samples <- rdirichlet( n = n_sim, alpha = alpha )
  
  # Compute theta_hat for all sampled weights
  theta_hat <- apply( samples, 1, function(w) { sum(w * z) } )
  
  # Norms on weights
  expected_2norm2 <- mean( apply( samples, 1, function(w) { sum(w^2) } ) )
  expected_3norm3 <- mean( apply( samples, 1, function(w) { sum(w^3) } ) )
  exact_expected_2norm2 <- (1 + lambda) / (1 + lambda * n)
  # exact_expected_3norm3 <- ((1 + lambda) * (2 + lambda)) / ((1 + n * lambda) * (2 + n * lambda))
  exact_expected_3norm3 <- (lambda^2 + 3 * lambda + 2) / ( (n * lambda)^2 + 3 * n * lambda + 2 )
  exact_expected_3norm3

  expected_2norm2; exact_expected_2norm2  # should be similar
  expected_3norm3; exact_expected_3norm3  # should be similar
 
  
  # Compute RHS of identity
  RHS <- M3Exact( z = z,
                  w_bar = w_bar,
                  exp3norm3 = exact_expected_3norm3,
                  # exp2norm2 = exact_expected_2norm2,
                  expw2 = unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  RHS  
  
  
  
  # Compute LHS using E(w_i^3), E(w_i^2 w_j) and E(w_i w_j, w_k)
  
  wi3_bar <- unlist( lapply( alpha, FUN = betaMoments, a0 = sum(alpha), m = 3 ) )
  
  
  # tmp1 <- 0
  # for ( i in 1:n ) {
  #   for ( j in 1:n ) {
  #     if ( i != j ) {
  #       tmp1 <- tmp1 + wi2wj_mat[i, j] * b[i]^2  * b[j] * 3
  #     }
  #   }
  # }
  # tmp2 <- 0
  # for ( i in 1:(n-2) ) {
  #   for ( j in (i+1):(n-1) ) {
  #     for ( k in (j+1):n ) {
  #       tmp2 <- tmp2 + wiwjwk_array[i, j, k] * prod(b[c(i, j, k)]) * 6
  #     }
  #   }
  # }
  # LHS_version5 <- sum(wi3_bar * b^3) + tmp1 + tmp2
  # LHS_version5
  

  # Compare RHS, LHS and numerical result
  RHS
  LHS
  sum( (theta_hat - mean(theta_hat))^3 / length(theta_hat) )
  
  
  
  
  
  
  
  
  
  
  
  
  # --------------------------------------------------------------------------
  # Weights follow an asymmetric Dirichlet distribution
  # --------------------------------------------------------------------------
  
  
  # Sample weights from a Dirichlet distribution (with symmetric parameter)
  alpha <- 1:n / sum(1:n) #* n
  samples <- rdirichlet( n = n_sim, alpha = alpha )
  
  # Compute theta_hat for all sampled weights
  theta_hat <- apply( samples, 1, function(w) { sum(w * z) } )
  
  # Norms on weights
  w_bar <- alpha / sum(alpha)
  squared_2norm_w_bar <- sum(w_bar^2)
  expected_2norm2 <- mean( apply( samples, 1, function(w) { sum(w^2) } ) )
  expected_3norm3 <- mean( apply( samples, 1, function(w) { sum(w^3) } ) )
  exact_expected_2norm2 <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  exact_expected_3norm3 <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 3 ) ) )
  
  expected_2norm2; exact_expected_2norm2 # they should be close
  expected_3norm3; exact_expected_3norm3 # they should be close
  
  
  # Compute RHS of identity
  RHS <- M3Exact( z = z,
                  w_bar = w_bar,
                  exp3norm3 = exact_expected_3norm3,
                  # exp2norm2 = exact_expected_2norm2,
                  expw2 = unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  RHS  
  sum( (theta_hat - mean(theta_hat))^3 / length(theta_hat) )
  
  
  
  
  
  
  
  
  
    
  
  
  
  
  
  
  
  
  
  
  