  
  
  ############################################################################
  ### IDENTITY FOR r=3
  ############################################################################
  
  
  # --------------------------------------------------------------------------
  # Cyril Bachelard
  # This version:     20.07.2022
  # First version:    20.07.2022
  # --------------------------------------------------------------------------
  
  
  # Description:
  # This scripts defines an (arbitrarily) real-valued vector z and computes the 
  # RHS and LHS of the identity for the following case:
  # 1) Weights are distributed over a grid on the simplex (of dimension n). 
  # The grid is generated by computing all possible partitions of integer n and all 
  # possible permutations (this can only be done for n < 9).
 
  
  
  
  
  
  require(partitions)
  require(gtools)
  
  
  wd <- "H:/R/notingit/Bootstrap/"
  source( paste0(wd, "Source/custom_functions.R") )
  
  
  
  
  # --------------------------------------------------------------------------
  # Data and parameters
  # --------------------------------------------------------------------------
  
  # Define real-valued vector z
  n <- 4
  set.seed(1111)
  z <- rt(n = n, df = 3)^2
  
  w_bar <- rep(1/n, n)
  z_bar <- sum( w_bar * z )
  b <- z - z_bar
  
  # Number of simulations (for the Dirichlet sampling case)
  n_sim <- 10^6
  
  
 
  
  # --------------------------------------------------------------------------
  # Weights follow a Grid G over the simplex
  # --------------------------------------------------------------------------
  
  # Define grid G (exactly, using partitions and permutations)

  # Partitions
  parts_mat <- partitions::parts( n )
  draws <- gridDraws( parts_mat = parts_mat, cnames = FALSE )
  prob <- draws2prob( draws = draws )
  prob_tot <- prob * draws[2, ]
  
  # Permutations
  lP <- list()
  lTheta <- list()
  for( j in 1:ncol(parts_mat) ) {
    
    if ( length(unique(parts_mat[ ,j])) > 1 ) {
      perm <- gtools::permutations( n = n, 
                                    r = n, 
                                    v = parts_mat[ ,j], 
                                    set = FALSE,
                                    repeats.allowed = FALSE )
      perm_unique <- perm[!duplicated(perm), ]
    } else {
      perm_unique <- t(parts_mat[ ,j])
    }
    lP[[j]] <- perm_unique
    theta <- apply( perm_unique / n, 1, function(p) { sum(p * z) } )
    lTheta[[j]] <- theta
  }
  gridnodes_all <- do.call( rbind, lP )
  Grid <- gridnodes_all / n
  Grid
  dim(Grid)
  
  # Grid node activation probabilities (there are k \in \{1, ..., K\} grid nodes)
  lProb <- lapply( 1:length(lP), FUN = function(i) { rep(prob[i], nrow(lP[[i]])) } )
  prob_k <- unlist(lProb)

  # Norms on weights (grid nodes)
  w_bar_3norm3 <- sum(w_bar^3)
  exact_expected_2norm2 <- (2*n-1) / n^2 
  exact_expected_3norm3 <- (5*n^2 - 6*n + 2) / n^4
  expected_2norm2 <- sum( apply( Grid, 1, function(w) { sum(w^2) } ) * prob_k )
  expected_3norm3 <- sum( apply( Grid, 1, function(w) { sum(w^3) } ) * prob_k )
 
  sum( apply( parts_mat / n, 2, function(x) { sum(x^2) } ) * prob_tot )
  expected_2norm2; exact_expected_2norm2  # should be the same
  
  sum( apply( parts_mat / n, 2, function(x) { sum(x^3) } ) * prob_tot )
  expected_3norm3; exact_expected_3norm3  # should be the same
 
  
  
  
  
  # Compute RHS of identity
  m3_biased <- sum( w_bar * b^3 )
  bias_correction <- biasCorrection( w_bar = w_bar, m = 3 )
  m3 <- m3_biased * bias_correction
  RHS <- M3Exact( z = z,
                  w_bar = w_bar,
                  exp3norm3 = exact_expected_3norm3,
                  expw2 = rep(exact_expected_2norm2 / n, n) )
  RHS
  
  
  
  # The LHS of the identy can be computed in several ways
  tmp <- apply( Grid, 1, function(w) { sum(w * b)^3 } )
  # tmp <- apply( Grid, 1, function(w) { (sum(w * z) - z_bar)^3 } )
  LHS_version1 <- sum( prob_k * tmp )
  LHS_version1

  
  
  
 
  
  

  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 3)
  wi3_mat <- matrix(0, nrow = 1, ncol = n)
  wi2wj_mat <- matrix(0, nrow = n, ncol = n)
  wiwjwk_array <- array(0, dim = c(n, n, n))
  
  for ( row_idx in 1:nrow(Grid) ) {
    wi2wj_mat_tmp <- wi2wj_mat * 0
    wiwjwk_array_tmp <- wiwjwk_array * 0
    g <- as.numeric(Grid[row_idx, ])
    Ans[row_idx, 1] <- sum(g^3 * b^3)
    wi3_mat[1, ] <- wi3_mat[1, ] + g^3 * prob_k[row_idx]
    tmp <- 0
    for ( i in 1:n ) {
      for ( j in 1:n ) {
        if ( i != j ) {
          wi2wj_mat_tmp[i, j] <- g[i]^2 * g[j]
          tmp <- tmp  + wi2wj_mat_tmp[i, j] * b[i]^2  * b[j] * 3
        }
      }
    }
    wi2wj_mat <- wi2wj_mat + wi2wj_mat_tmp * prob_k[row_idx]
    Ans[row_idx, 2] <- tmp
    tmp <- 0
    for ( i in 1:(n-2) ) {
      for ( j in (i+1):(n-1) ) {
        for ( k in (j+1):n ) {
          wiwjwk_array_tmp[i, j, k] <- prod(g[c(i, j, k)])
          tmp <- tmp  + wiwjwk_array_tmp[i, j, k] * prod(b[c(i, j, k)]) * 6
        }
      }
    }
    wiwjwk_array <- wiwjwk_array + wiwjwk_array_tmp * prob_k[row_idx]
    Ans[row_idx, 3] <- tmp
  }
  LHS_version2 <- sum( apply( Ans, 2, function(a) { sum(a * prob_k) } ) )
  LHS_version2
  
  wi3_mat
  wi2wj_mat
  wiwjwk_array
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    tmp <- 0
    for ( i in 1:n) {
      for (j in 1:n) {
        for (k in 1:n) {
          tmp <- tmp + prod(g[c(i, j, k)]) * prod(b[c(i, j, k)])
        }
      }
    }
    Ans[row_idx, 1] <- tmp
  }
  LHS_version3 <- sum( Ans[ ,1] * prob_k )
  LHS_version3
  
  
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  B_tmp <- b %*% t(b)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    G_tmp <- g %*% t(g)
    Ans[row_idx, 1] <- sum( kronecker( g * b, G_tmp * B_tmp ) )
  }
  LHS_version4 <- sum(Ans[ ,1] * prob_k) 
  
  
  
 
  
  # Or, use E(w_i^3), E(w_i^2 w_j) and E(w_i w_j, w_k)
 
  wi3_bar <- apply( Grid^3 * prob_k, 2, sum )
  tmp1 <- 0
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      if ( i != j ) {
        tmp1 <- tmp1 + wi2wj_mat[i, j] * b[i]^2  * b[j] * 3
      }
    }
  }
  tmp2 <- 0
  for ( i in 1:(n-2) ) {
    for ( j in (i+1):(n-1) ) {
      for ( k in (j+1):n ) {
        tmp2 <- tmp2 + wiwjwk_array[i, j, k] * prod(b[c(i, j, k)]) * 6
      }
    }
  }
  LHS_version5 <- sum(wi3_bar * b^3) + tmp1 + tmp2
  LHS_version5
  
  
  
  wi3_bar <- apply( Grid^3 * prob_k, 2, sum )
  wi2wj_mat
  
  
  
  
  LHS_version1
  LHS_version2
  LHS_version3
  LHS_version4
  LHS_version5
  RHS
  
  
  
  
  #################
  
  # E(w_i^3 w_j)
  
  W <- t( apply( Grid, 1, function(g) { (g^3 %*% t(g))[upper.tri(g %*% t(g))] } ) )
  
  
  
  # E(w_i^2 w_j)
  
  W <- t( apply( Grid, 1, function(g) { (g^2 %*% t(g))[upper.tri(g %*% t(g))] } ) )
  if ( nrow(W) == 1 ) W <- t(W)
  wi2wj_bar_xxx <- apply( W * prob_k, 2, sum )
  wi2wj_bar_mat_xxx <- matrix(NA, nrow = n, ncol = n, byrow = TRUE)
  wi2wj_bar_mat_xxx[upper.tri(wi2wj_bar_mat_xxx)] <- wi2wj_bar_xxx
  
  wi2wj_bar_mat_xxx
  wi2wj_mat
  
  
  # E(w_i w_j, w_k)
  
  FUN <- function(g)
  {
    c( prod(g[c(1, 2, 3)]), 
       prod(g[c(1, 2, 4)]),
       prod(g[c(1, 3, 4)]),
       prod(g[c(2, 3, 4)]) )
  }
  W <- t( apply( Grid, 1, FUN ) )
  wiwjwk_bar_xxx <- apply( W * prob_k, 2, sum )
  
  wiwjwk_array
  wiwjwk_bar_xxx
  
  
  wi3_bar
  wi2wj_bar_xxx
  wiwjwk_bar_xxx
  
  
  a1 <- wi3_bar[1]
  a2 <- wi2wj_bar_xxx[1]
  a3 <- wiwjwk_bar_xxx[1]
  
  
  a1; (5*n^2 - 6*n + 2) / n^5
  
  
  a1 * n^5
  a2 * n^5
  
  
  
  
  
  
  
  
  
  
  
  
  