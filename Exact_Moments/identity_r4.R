  
  
  ############################################################################
  ### IDENTITY FOR r=4
  ############################################################################
  
  
  # --------------------------------------------------------------------------
  # Cyril Bachelard
  # This version:     20.07.2022
  # First version:    20.07.2022
  # --------------------------------------------------------------------------
  
  
  # Description:
  # This scripts defines an (arbitrarily) real-valued vector z and computes the 
  # RHS and LHS of the identity for two cases:
  # 1) Weights are distributed over a grid on the simplex (of dimension n). 
  # The grid is generated by computing all possible partitions of integer n and all 
  # possible permutations (this can only be done for n < 9).
  # 2) Weights follow a Dirichlet distribution. In the example below, the parametrization
  # of the Dirichlet distribution is such that weights are uniformly distributed over the
  # simplex. However, this can be changed (parameter alpha). 
  
  
  
  
  # # Appendix B
  # 
  # set.seed(1)
  # n <- 5
  # w <- rdirichlet(1, alpha = rep(1, n))
  # w_bar <- 1:n / sum(1:n)
  # 
  # 
  # # r = 2
  # sum( (w - w_bar)^2 )
  # sum(w^2) - sum(w_bar^2)
  # 
  # # r = 3
  # sum( (w - w_bar)^3 )
  # sum(w^3) - sum(w_bar^3) - 3 * sum(w^2 * w_bar) + 3 * sum(w * w_bar^2)
  # sum(w^3) - sum(w_bar^3) - 3 * sum(w^2) * sum(w_bar^2) + 2 * sum(w_bar^2)
  # 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  require(partitions)
  require(gtools)
  
  
  wd <- "H:/R/notingit/Bootstrap/"
  source( paste0(wd, "Source/custom_functions.R") )
  
  
  # --------------------------------------------------------------------------
  # Helper functions
  # --------------------------------------------------------------------------
  
  # --------------------------------------------------------------------------
  rdirichlet <- function( n, alpha ) 
  {
    l <- length(alpha)
    x <- matrix( rgamma(l * n, alpha), ncol = l, byrow = TRUE )
    sm <- x %*% rep(1, l)
    ans <- x / as.vector(sm)
    return( ans )
  }
   
  
  # --------------------------------------------------------------------------
  gridDraws <- function ( parts_mat, cnames = FALSE ) 
  {
    FUN <- function ( x ) 
    {
      tmp <- table(x)
      num1 <- factorial(sum(x))
      if ( length(x) == sum(x) ) {
        num2 <- num1
      } else {
        num2 <- factorial(length(x))
      }
      n_paths_to_level_set <- num1 / prod(factorial(x))
      n_points_in_level_set <- num2 / prod(factorial(tmp))
      ans <- c(n_paths_to_level_set,
               n_points_in_level_set)
      return( ans )
    }
    ans <- apply( X = parts_mat, MARGIN = 2, FUN = FUN )
    rownames(ans) <- c("# paths to the same point", 
                       "# points in the same level set")
    if ( isTRUE(cnames) ) {
      colnames(ans) <- apply( X = parts_mat, 
                              MARGIN = 2, 
                              FUN = function(X) { paste(X, collapse = ".") } )
    }
    return( ans )
  }
  
  # --------------------------------------------------------------------------
  draws2prob <- function ( draws ) 
  {
    ans <- draws[1, ] / as.numeric(draws[1, ] %*% draws[2, ])
    return( ans )
  }
  
  
  # --------------------------------------------------------------------------
  betaMoments <- function( a, a0, m )
  {
    mvec <- 0:(m-1)
    # prod( a + mvec ) / prod( a + b + mvec )
    prod( (a + mvec) / (a0 + mvec) )
  }
  
  
  
  
  # --------------------------------------------------------------------------
  # Data and parameters
  # --------------------------------------------------------------------------
  
  # Define real-valued vector z
  n <- 4
  set.seed(1111)
  z <- rt(n = n, df = 3)^2

  w_bar <- rep(1/n, n)
  z_bar <- sum( w_bar * z )
  b <- z - z_bar
  
  # Number of simulations (for the Dirichlet sampling case)
  n_sim <- 10^6
  
  
  
 
  # --------------------------------------------------------------------------
  # Classical bootstrap
  # --------------------------------------------------------------------------
  
  Boot <- boot::boot( data = z,
                      statistic = meanBoot,
                      R = n_sim )
  mean(Boot$t); Boot$t0
  var(Boot$t)
  sum( (Boot$t - mean(Boot$t))^2 ) / length(Boot$t)
  sum( (Boot$t - mean(Boot$t))^3 ) / length(Boot$t)
  sum( (Boot$t - mean(Boot$t))^4 ) / length(Boot$t)
  
  
  
  
  # --------------------------------------------------------------------------
  # Weights follow a Grid G over the simplex
  # --------------------------------------------------------------------------
  
  # Define grid G (exactly, using partitions and permutations)

  # Partitions
  parts_mat <- partitions::parts( n )
  draws <- gridDraws( parts_mat = parts_mat, cnames = FALSE )
  prob <- draws2prob( draws = draws )
  prob_tot <- prob * draws[2, ]
  
  # Permutations
  lP <- list()
  lTheta <- list()
  for( j in 1:ncol(parts_mat) ) {
    
    if ( length(unique(parts_mat[ ,j])) > 1 ) {
      perm <- gtools::permutations( n = n, 
                                    r = n, 
                                    v = parts_mat[ ,j], 
                                    set = FALSE,
                                    repeats.allowed = FALSE )
      perm_unique <- perm[!duplicated(perm), ]
    } else {
      perm_unique <- t(parts_mat[ ,j])
    }
    lP[[j]] <- perm_unique
    theta <- apply( perm_unique / n, 1, function(p) { sum(p * z) } )
    lTheta[[j]] <- theta
  }
  gridnodes_all <- do.call( rbind, lP )
  Grid <- gridnodes_all / n
  Grid
  dim(Grid)
  
  # Grid node activation probabilities (there are k \in \{1, ..., K\} grid nodes)
  lProb <- lapply( 1:length(lP), FUN = function(i) { rep(prob[i], nrow(lP[[i]])) } )
  prob_k <- unlist(lProb)

  # Norms on weights (grid nodes)
  w_bar_3norm3 <- sum(w_bar^3)
  exact_expected_2norm2 <- (2*n-1) / n^2 
  exact_expected_3norm3 <- (5*n^2 - 6*n + 2) / n^4
  
  expected_2norm2 <- sum( apply( Grid, 1, function(w) { sum(w^2) } ) * prob_k )
  expected_3norm3 <- sum( apply( Grid, 1, function(w) { sum(w^3) } ) * prob_k )
  expected_4norm4 <- sum( apply( Grid, 1, function(w) { sum(w^4) } ) * prob_k )
  
 
  sum( apply( parts_mat / n, 2, function(x) { sum(x^2) } ) * prob_tot )
  expected_2norm2; exact_expected_2norm2  # should be the same
  
  sum( apply( parts_mat / n, 2, function(x) { sum(x^3) } ) * prob_tot )
  expected_3norm3; exact_expected_3norm3  # should be the same
  
  sum( apply( parts_mat / n, 2, function(x) { sum(x^4) } ) * prob_tot )
  expected_4norm4; exact_expected_4norm4  # should be the same
  
 
  
  bc_2 <- biasCorrection( w_bar = w_bar, m = 2 )
  bc_2_unw <- biasCorrection( N = length(w_bar), m = 2, unweighted = TRUE )
  bc_3 <- biasCorrection( w_bar = w_bar, m = 3 )
  bc_3_unw <- biasCorrection( N = length(w_bar), m = 3, unweighted = TRUE )
  bc_4 <- biasCorrection( w_bar = w_bar, m = 4 )
  bc_4_unw <- biasCorrection( N = length(w_bar), m = 4, unweighted = TRUE )
  
  bc_2; bc_2_unw
  bc_3; bc_3_unw
  bc_4[1] / bc_4[3]; bc_4_unw[1] / bc_4_unw[3]
  bc_4[2] / bc_4[3]; bc_4_unw[2] / bc_4_unw[3]
  
  
  
  
  # Compute RHS of identity
  m2_biased <- sum( w_bar * b^2 )
  m4_biased <- sum( w_bar * b^4 )
  bias_correction <- biasCorrection( w_bar = w_bar, m = 4 )
  m4 <- (m4_biased * bias_correction[1] - m2_biased^2 * bias_correction[2]) / bias_correction[3]
  
  
  
  mu_4 <- sum( prob_k * apply( Grid, 1, function(w) { sum(w * b)^4 } ) )
  mu_4
  
  
  
  
  
  expw3 <- rep(exact_expected_3norm3 / n, n)
  expw2 <- rep(exact_expected_2norm2 / n, n)
  expected_4norm4 - 3 * sum(w_bar^4) - 4 * sum(w_bar * expw3) + 6 * sum(w_bar^2 * expw2)
  sum( prob_k * apply( Grid, 1, function(x) { sum((x - w_bar)^4) } ) )
  mu_4 / m4
  
  
  tmp <- expected_4norm4 - 3 * sum(w_bar^4) - 4 * sum(w_bar * expw3) + 6 * sum(w_bar^2 * expw2)
  (m4_biased * bias_correction[1] / bias_correction[3]) * tmp - 
    (m2_biased^2 * bias_correction[2] / bias_correction[3]) * (expected_2norm2 - sum(w_bar^2))^2
  
  
  
  
  
  
  
  
  
  
  # debugonce( M4Exact )
  RHS <- M4Exact( z = z,
                  w_bar = w_bar,
                  exp4norm4 = expected_4norm4,
                  expw3 = rep(exact_expected_3norm3 / n, n),
                  expw2 = rep(exact_expected_2norm2 / n, n) )
  RHS
  sum( (Boot$t - mean(Boot$t))^4 ) / length(Boot$t)
  
  
  
  apply( Grid, 2, function(x) { sum(prob_k * x^2) } )
  sum( apply( Grid, 2, function(x) { sum(prob_k * x^2) } ) )
  exact_expected_2norm2
  
  apply( Grid, 2, function(x) { sum(prob_k * x^3) } )
  sum( apply( Grid, 2, function(x) { sum(prob_k * x^3) } ) )
  exact_expected_3norm3
  
  
  
  
  
  
  # The LHS of the identy can be computed in several ways
  tmp <- apply( Grid, 1, function(w) { sum(w * b)^4 } )
  LHS_version1 <- sum( prob_k * tmp )
  LHS_version1


 
  
  
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 4)
  wi4_mat <- matrix(0, nrow = 1, ncol = n)
  wi2wj_mat <- matrix(0, nrow = n, ncol = n)
  wiwjwk_array <- array(0, dim = c(n, n, n))
  wiwjwkwl_array <- array(0, dim = c(n, n, n, n))
  
  for ( row_idx in 1:nrow(Grid) ) {
   
    wi2wj_mat_tmp <- wi2wj_mat * 0
    wiwjwk_array_tmp <- wiwjwk_array * 0
    wiwjwkwl_array_tmp <- wiwjwkwl_array * 0
    g <- as.numeric(Grid[row_idx, ])
    Ans[row_idx, 1] <- sum(g^4 * b^4)
    wi4_mat[1, ] <- wi4_mat[1, ] + g^4 * prob_k[row_idx]
    
    tmp <- 0
    for ( i in 1:n ) {
      for ( j in 1:n ) {
        if ( i != j ) {
          wi2wj_mat_tmp[i, j] <- g[i]^2 * g[j]
          tmp <- tmp  + wi2wj_mat_tmp[i, j] * b[i]^2  * b[j] * 3
        }
      }
    }
    wi2wj_mat <- wi2wj_mat + wi2wj_mat_tmp * prob_k[row_idx]
    Ans[row_idx, 2] <- tmp
    
    tmp <- 0
    for ( i in 1:(n-2) ) {
      for ( j in (i+1):(n-1) ) {
        for ( k in (j+1):n ) {
          wiwjwk_array_tmp[i, j, k] <- prod(g[c(i, j, k)])
          tmp <- tmp  + wiwjwk_array_tmp[i, j, k] * prod(b[c(i, j, k)]) * 6
        }
      }
    }
    wiwjwk_array <- wiwjwk_array + wiwjwk_array_tmp * prob_k[row_idx]
    Ans[row_idx, 3] <- tmp
    
    tmp <- 0
    for ( i in 1:(n-3) ) {
      for ( j in (i+1):(n-2) ) {
        for ( k in (j+1):(n-1) ) {
          for ( l in (k+1):n ) {
            wiwjwkwl_array_tmp[i, j, k, l] <- prod(g[c(i, j, k, l)])
            tmp <- tmp  + wiwjwkwl_array_tmp[i, j, k, l] * prod(b[c(i, j, k, l)]) * 6
          }
        }
      }
    }
    wiwjwkwl_array <- wiwjwkwl_array + wiwjwkwl_array_tmp * prob_k[row_idx]
    Ans[row_idx, 4] <- tmp
  }
  LHS_version2 <- sum( apply( Ans, 2, function(a) { sum(a * prob_k) } ) )
  LHS_version2
  
  wi3_mat
  wi2wj_mat
  wiwjwk_array
  wiwjwkwl_array
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    tmp <- 0
    for ( i in 1:n) {
      for (j in 1:n) {
        for (k in 1:n) {
          for (l in 1:n) {
            tmp <- tmp + prod(g[c(i, j, k, l)]) * prod(b[c(i, j, k, l)])
          }
        }
      }
    }
    Ans[row_idx, 1] <- tmp
  }
  LHS_version3 <- sum( Ans[ ,1] * prob_k )
  LHS_version3
  
  
  
  
  # Or:
  Ans <- matrix(0, nrow = nrow(Grid), ncol = 1)
  B_tmp <- b %*% t(b)
  for ( row_idx in 1:nrow(Grid) ) {
    g <- as.numeric(Grid[row_idx, ])
    G_tmp <- g %*% t(g)
    Ans[row_idx, 1] <- sum( kronecker( g * b, G_tmp * B_tmp ) )
  }
  LHS_version4 <- sum(Ans[ ,1] * prob_k) 
  LHS_version4 
  
  
 
  # Or, use E(w_i^4), E(w_i^2, w_j^2), E(w_i^3 w_j), E(w_i^2, w_j, w_k) 
  # and E(w_i w_j, w_k, w_l)

  wi3_bar <- apply( Grid^3 * prob_k, 2, sum )
  tmp1 <- 0
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      if ( i != j ) {
        tmp1 <- tmp1 + wi2wj_mat[i, j] * b[i]^2  * b[j] * 3
      }
    }
  }
  tmp2 <- 0
  for ( i in 1:(n-2) ) {
    for ( j in (i+1):(n-1) ) {
      for ( k in (j+1):n ) {
        tmp2 <- tmp2 + wiwjwk_array[i, j, k] * prod(b[c(i, j, k)]) * 6
      }
    }
  }
  LHS_version5 <- sum(wi3_bar * b^3) + tmp1 + tmp2
  LHS_version5
  
  
  
  
  LHS_version1
  LHS_version2
  LHS_version3
  LHS_version4
  LHS_version5
  RHS
  
  
  
  ###########################
  
  
  # Cales - Nested sums
  # Lemma 3
  
  
  x <- 1:n
  tmp <- 0
  for ( i in 1:n ) {
    for ( j in i:n ) {
      tmp <- tmp + x[i] * x[j]
    }
  }
  2 * tmp
  sum(x)^2 + sum(x^2)
  sum( x %*% t(x) )
  
  x <- 1:n
  tmp <- 0
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      tmp <- tmp + x[i] * x[j]
    }
  }
  tmp
  
  
  
  
  
  
  
  
  
  
  
  
    
  
  # --------------------------------------------------------------------------
  # Weights follow an asymmetric Dirichlet distribution
  # --------------------------------------------------------------------------
  
  
  # Sample weights from a Dirichlet distribution (with symmetric parameter)
  # alpha <- 1:n / sum(1:n) * n
  #
  alpha <- rep(1, n)
  #
  samples <- rdirichlet( n = n_sim, alpha = alpha )
  
  # Compute theta_hat for all sampled weights
  theta_hat <- apply( samples, 1, function(w) { sum(w * z) } )
  
  # Norms on weights
  w_bar <- alpha / sum(alpha)
  squared_2norm_w_bar <- sum(w_bar^2)
  expected_2norm2 <- mean( apply( samples, 1, function(w) { sum(w^2) } ) )
  expected_3norm3 <- mean( apply( samples, 1, function(w) { sum(w^3) } ) )
  expected_4norm4 <- mean( apply( samples, 1, function(w) { sum(w^4) } ) )
  exact_expected_2norm2 <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  exact_expected_3norm3 <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 3 ) ) )
  exact_expected_4norm4 <- sum( unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 4 ) ) )
  
  expected_2norm2; exact_expected_2norm2 # they should be close
  expected_3norm3; exact_expected_3norm3 # they should be close
  expected_4norm4; exact_expected_4norm4 # they should be close
  
  
  
  # Compute RHS of identity
  # debugonce( M4Exact )
  RHS <- M4Exact( z = z,
                  w_bar = w_bar,
                  exp4norm4 = exact_expected_4norm4,
                  expw3 = unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 3 ) ),
                  expw2 = unlist( lapply( alpha, betaMoments, a0 = sum(alpha), m = 2 ) ) )
  RHS  
  sum( (theta_hat - mean(theta_hat))^4 / length(theta_hat) )
  
  
  
  
  
  
  
  
  
    
  # --------------------------------------------------------------------------
  # Loop over increasing n
  # --------------------------------------------------------------------------
  
  n_vec <- 4:50
  n_sim <- 10^5
  z_vec <- rt( n = max(n_vec), df = 4 )
  m2_bb <- rep(NA, length(n_vec))
  m3_bb <- rep(NA, length(n_vec))
  m4_bb <- rep(NA, length(n_vec))
  
  for ( i in seq(along = n_vec) ) {
    
    n <- n_vec[i]
    z <- z_vec[1:n]
    alpha <- rep(1, n)
    samples <- rdirichlet( n = n_sim, alpha = alpha )
    theta <- apply( samples, 1, function(w) { sum(w * z) } )
    m2_bb[i] <- sum( (theta - mean(theta))^2 ) / length(theta)
    m3_bb[i] <- sum( (theta - mean(theta))^3 ) / length(theta)
    m4_bb[i] <- sum( (theta - mean(theta))^4 ) / length(theta)
    
    
  }
  
  exp2norm2 <- unlist( lapply( n_vec, FUN = function(n) { sum(unlist(lapply(rep(1, n), betaMoments, a0 = n, m = 2))) } ) )
  exp3norm3 <- unlist( lapply( n_vec, FUN = function(n) { sum(unlist(lapply(rep(1, n), betaMoments, a0 = n, m = 3))) } ) )
  exp4norm4 <- unlist( lapply( n_vec, FUN = function(n) { sum(unlist(lapply(rep(1, n), betaMoments, a0 = n, m = 4))) } ) )
  m2_tilde <- unlist(lapply(n_vec, FUN = function(n) { sum( (z_vec[1:n] - mean(z_vec[1:n]))^2 ) / n } ))
  m3_tilde <- unlist(lapply(n_vec, FUN = function(n) { sum( (z_vec[1:n] - mean(z_vec[1:n]))^3 ) / n } ))
  m4_tilde <- unlist(lapply(n_vec, FUN = function(n) { sum( (z_vec[1:n] - mean(z_vec[1:n]))^4 ) / n } ))
  m4 <- (m4_tilde * bc_4[ ,1] - m2_tilde^2 * bc_4[ ,2]) / bc_4[ ,3]
  bc_2 <- unlist(lapply(n_vec, FUN = function(n) { biasCorrection(N = n, unweighted = TRUE, m = 2) } ))
  bc_3 <- unlist(lapply(n_vec, FUN = function(n) { biasCorrection(N = n, unweighted = TRUE, m = 3) } ))
  bc_4 <- t( do.call( cbind, lapply(n_vec, FUN = function(n) { biasCorrection(N = n, unweighted = TRUE, m = 4) } ) ) )
  tmp_2 <- (exp2norm2 - 1/n_vec)
  tmp_3 <- exp3norm3 + 2 * unlist(lapply(n_vec, FUN = function(n) { n * (1/n)^3 } )) - 
            3 * exp2norm2 * 1/n_vec
  tmp_4 <- exp4norm4 - 3 * unlist(lapply(n_vec, FUN = function(n) { n * (1/n)^4 } )) - 
            4 * exp3norm3 * 1/n_vec +
              6 *  exp2norm2 * 1/n_vec^2
  
  
  plot( m2_bb,  tmp_2 * m2_tilde * bc_2, type = "o" )
  plot( m3_bb,  exp3norm3 * m3_tilde, type = "o" )
  plot( m3_bb,  tmp_3 * m3_tilde * bc_3, type = "o" )
  
  
  
  
  plot( m4_bb )
  plot( m4_bb,  (exp4norm4 * m4_tilde) / 2, type = "o" )
  cbind( m4_bb, (exp4norm4 * m4_tilde) / 2 )
  
  plot( m4_bb,  tmp_4 * (m4_tilde * bc_4[ ,1] - m2_tilde^2 * bc_4[ ,2]) / bc_4[ ,3], type = "o" )
  plot( m4_bb,  (m4_tilde * bc_4[ ,1] - m2_tilde^2 * bc_4[ ,2]) / bc_4[ ,3], type = "o" )
  
  
  plot( m4_bb,  (exp4norm4 * exp2norm2) * m4, type = "o" )
  
  
  
  
 
  
  
  tmp <- m4_bb / m4
  plot( tmp, exp4norm4, type = "o" )  
  
  
  
  
  
  ###############################################################################################
  
  n <- 5
  x <- 1 + rnorm(n)

  xi4 <- 0
  xi3xj <- 0
  xi2xj2 <- 0
  xi2xjxk <- 0
  xixjxkxl <- 0
  
  for ( i in 1:n ) {
    xi4 <- xi4 + x[i]^4
  }
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      if ( i != j ) {
        xi3xj <- xi3xj + x[i]^3 * x[j]
      }
    }
  }
  for ( i in 1:(n-1) ) {
    for ( j in (i+1):n ) {
      xi2xj2 <- xi2xj2 + x[i]^2 * x[j]^2
    }
  }
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      for ( k in 1:n ) {
        if ( j != i ) {
          if ( k != j && k != i ) {
            xi2xjxk <- xi2xjxk + x[i]^2 * x[j] * x[k]
          }
        }
      }
    }
  }
  for ( i in 1:(n-3) ) {
    for ( j in (i+1):(n-2) ) {
      for ( k in (j+1):(n-1) ) {
        for ( l in (k+1):n ) {
          xixjxkxl <- xixjxkxl + prod(x[c(i, j, k, l)])
        }
      }
    }
  }
  
  xi4
  xi3xj
  xi2xj2
  xi2xjxk
  xixjxkxl
  
  A <- x %*% t(x)
  B <- as.numeric(A) %*% t(as.numeric(A))
  sum(B)  
  sum(x)^4  # same same
  xi4 + 4 * xi3xj + 6 * xi2xj2 + 6 * xi2xjxk + 24 * xixjxkxl # same same
 
  
  
  
  
  ###############################################################################################
  
  x <- c(1, 0, 2, 5)
  n <- length(x)
  
  xi3 <- 0
  xi2xj <- 0
  xixjxk <- 0
  
  for ( i in 1:n ) {
    xi3 <- xi3 + x[i]^3
  }
  for ( i in 1:n ) {
    for ( j in 1:n ) {
      if ( i != j ) {
        xi2xj <- xi2xj + x[i]^2 * x[j]
      }
    }
  }
  for ( i in 1:(n-2) ) {
    for ( j in (i+1):(n-1) ) {
      for ( k in (j+1):n ) {
        xixjxk <- xixjxk + prod(x[c(i, j, k)])
      }
    }
  }
  
  
  sum(x)^3 
  xi3 + 3 * xi2xj + 6 * xixjxk
  
  

  
  
  
  
  
  
  
  
  
  